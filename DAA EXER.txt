Merge Sort:
#include<stdio.h>
#include<stdlib.h>
void merge(int a[],int l,int m,int r)
{
	int i,j,k,n1,n2;
	n1=m-l+1;
	n2=r-m;
	int L[n1],R[n2];
	for(i=0;i<n1;i++)
	{
		L[i]=a[l+i];
	}
	for(j=0;j<n2;j++)
	{
		R[j]=a[m+1+j];
	}
	i=0;
	j=0;
	k=l;
	while(i<n1 && j<n2)
	{
		if(L[i]<=R[j])
		{
			a[k]=L[i];
			i++;
		}
		else
		{
			a[k]=R[j];
			j++;
		}
		k++;
	}
	while(i<n1)
	{
		a[k]=L[i];
		i++;
		k++;		
	}
	while(j<n2)
	{
		a[k]=R[j];
		j++;
		k++;
	}
}
void printArray(int a[],int s)
{
	int i=0;
	for(i=0;i<s;i++)
	{
		printf("%d\t",a[i]);
	}
}
void mergeSort(int a[],int l,int r,int s)
{
	int m;
	if(l<r)
	{
		m = l + (r-l)/2
		mergeSort(a,l,m,s);
		mergeSort(a,m+1,r,s);
		merge(a,l,m,r);
		printf("\n");
		printArray(a,s);
	}
}
int main()
{
	int a[10],i,j,s;
	printf("Enter 10 integers:");
	s=sizeof(a)/sizeof(a[0]);
	for(i=0;i<s;i++)
	{
		scanf("%d",&a[i]);
	}
	printf("Displaying integers: \n");
	printArray(a,s);
	mergeSort(a,0,s-1,s);
	printf("The sorted array is: \n");
	printArray(a,s);
}

Quick Sort:
#include<stdio.h>
#include<stdlib.h>
int swap(int *x,int *y)
{
	int temp;
	temp=*x;
	*x=*y;
	*y=temp;
	
}
int partition(int A[],int start,int end)
{
	int i;
	int pivot;
	pivot=A[end];
	int index;
	index=start;
	for(i=start;i<end;i++)
	{
		if(A[i]<=pivot)
		{
			swap(&A[i],&A[index]);
			index++;
		}
	}
	swap(&A[index],&A[end]);
	return index;
}
void quick(int A[],int start,int end)
{
	if(start<end)
	{
		int index=partition(A,start,end);
		quick(A,start,index-1);
		quick(A,index+1,end);
	}
}
void print(int A[],int s)
{
	int i;
	for(i=0;i<s;i++)
	{
		printf("%d\t",A[i]);
	}
	printf("\n");
}
int main()
{
	int A[8];
	int s=sizeof(A)/sizeof(A[0]);
	int i;
	printf("Enter 8 numbers : ");
	for(i=0;i<s;i++)
	{
		scanf("%d",&A[i]);
	}
	quick(A,0,s-1);
	for(i=0;i<s;i++)
	{
		printf("%d\t",A[i]);
	}
}


Prim's:
#include<stdio.h>
#include<stdlib.h>

#define infinity 9999
#define MAX 20

int G[MAX][MAX],spanning[MAX][MAX],n;

int prims();

int main()
{
	int i,j,total_cost;
	printf("Enter no. of vertices:");
	scanf("%d",&n);
	printf("\nEnter the adjacency matrix:\n");
	for(i=0;i<n;i++)
		for(j=0;j<n;j++)
			scanf("%d",&G[i][j]);
			total_cost=prims();
	printf("\ns Intermediate matrix :\n");
	for(i=0;i<n;i++){
		printf("\n");
	for(j=0;j<n;j++){
	printf("%d\t",spanning[i][j]);
	}}
	printf("\n\nTotal cost of spanning tree = %d",total_cost);
	return 0;
}

int prims()
{
	int cost[MAX][MAX];
	int u,v,min_distance,distance[MAX],from[MAX];
	int visited[MAX],no_of_edges,i,min_cost,j;
	//create cost[][] matrix,spanning[][]
	for(i=0;i<n;i++){
		for(j=0;j<n;j++){
			if(G[i][j]==0)
				cost[i][j]=infinity;
			else
				cost[i][j]=G[i][j];
		spanning[i][j]=0;
}}
	distance[0]=0;
	visited[0]=1;
	for(i=1;i<n;i++)
	{
		distance[i]=cost[0][i];
		from[i]=0;
		visited[i]=0;
	}
	min_cost=0; //cost of spanning tree
	no_of_edges=n-1; //no. of edges to be added
	while(no_of_edges>0)
	{
	//find the vertex at minimum distance from the tree
		min_distance=infinity;
		for(i=1;i<n;i++)
			if(visited[i]==0&&distance[i]<min_distance)
			{
				v=i;
				min_distance=distance[i];
			}
		u=from[v];
		//insert the edge in spanning tree
	spanning[u][v]=distance[v];
	spanning[v][u]=distance[v];
	no_of_edges--;
	visited[v]=1;
	//updated the distance[] array
	for(i=1;i<n;i++)
		if(visited[i]==0&&cost[i][v]<distance[i])
		{
			distance[i]=cost[i][v];
			from[i]=v;
		}
		min_cost=min_cost+cost[u][v];
	}
	return(min_cost);
}


Kruskal's:
#include <stdio.h>
#include <stdlib.h>

int comparator(const void* p1, const void* p2)
{
    int* x = (int*)p1;
    int* y = (int*)p2;

    return (*x) - (*y);
}

void makeSet(int parent[], int rank[], int n)
{
    for (int i = 0; i < n; i++) {
        parent[i] = i;
        rank[i] = 0;
    }
}

int findParent(int parent[], int component)
{
    if (parent[component] == component)
        return component;

    return parent[component] = findParent(parent, parent[component]);
}

void unionSet(int u, int v, int parent[], int rank[], int n)
{
    u = findParent(parent, u);
    v = findParent(parent, v);

    if (rank[u] < rank[v]) {
        parent[u] = v;
    }
    else if (rank[u] > rank[v]) {
        parent[v] = u;
    }
    else {
        parent[v] = u;
        rank[u]++;
    }
}

void kruskalAlgo(int n, int edge[][3], int m)
{
    qsort(edge, m, sizeof(edge[0]), comparator);

    int parent[n];
    int rank[n];

    makeSet(parent, rank, n);

    int minCost = 0;

    printf("Following are the edges in the constructed MST\n");
    for (int i = 0; i < m; i++) {
        int v1 = findParent(parent, edge[i][0]);
        int v2 = findParent(parent, edge[i][1]);
        int wt = edge[i][2];

        if (v1 != v2) {
            unionSet(v1, v2, parent, rank, n);
            minCost += wt;
            printf("%d -- %d == %d\n", edge[i][0], edge[i][1], wt);
        }
    }
    printf("Minimum Cost Spanning Tree: %d\n", minCost);
}

int main()
{
    int n, m;
    printf("Enter the number of vertices and edges: ");
    scanf("%d %d", &n, &m);

    int edge[m][3];
    printf("Enter the edges in the format u v w where u and v are the vertices and w is the weight:\n");
    for (int i = 0; i < m; i++) {
        scanf("%d %d %d", &edge[i][0], &edge[i][1], &edge[i][2]);
    }

    kruskalAlgo(n, edge, m);

    return 0;
}



Knapsack:
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define MAX_ITEMS 100
struct item {
    int weight;
    int value;
    float ratio;
};
int cmp_weight_asc(const void *a, const void *b) {
    struct item *item_a = (struct item *)a;
    struct item *item_b = (struct item *)b;
    return item_a->weight - item_b->weight;
}
int cmp_weight_desc(const void *a, const void *b) {
    struct item *item_a = (struct item *)a;
    struct item *item_b = (struct item *)b;
    return item_b->weight - item_a->weight;
}
int cmp_value_asc(const void *a, const void *b) {
    struct item *item_a = (struct item *)a;
    struct item *item_b = (struct item *)b;
    return item_a->value - item_b->value;
}
int cmp_value_desc(const void *a, const void *b) {
    struct item *item_a = (struct item *)a;
    struct item *item_b = (struct item *)b;
    return item_b->value - item_a->value;
}
int cmp_random(const void *a, const void *b) {
    return rand() % 3 - 1;
}
float fractional_knapsack(int n, struct item items[], int capacity) {
    float max_value = 0.0;
    int i;
    for (i = 0; i < n; i++) {
        items[i].ratio = (float)items[i].value / items[i].weight;
    }
    qsort(items, n, sizeof(struct item), cmp_random);
    for (i = 0; i < n && capacity > 0; i++) {
        if (items[i].weight <= capacity) {
            max_value += items[i].value;  
            capacity -= items[i].weight;
        } else {
            max_value += items[i].ratio * capacity;
            capacity = 0;
        }
    }
    return max_value;
}
int main() {
    int i, n, capacity, sort_method;
    struct item items[MAX_ITEMS];
    float max_value;
    float maxi;
    printf("Enter the number of items: ");
    scanf("%d", &n);
    printf("Enter the knapsack capacity: ");
    scanf("%d", &capacity);
    for (i = 0; i < n; i++) {
        printf("Enter the weight and value of item %d: ", i+1);
        scanf("%d %d", &items[i].weight, &items[i].value);
    }
    printf("Select the sorting method:\n");
    printf("1. Sort by weight in ascending order\n");
    qsort(items, n, sizeof(struct item), cmp_weight_asc);
    max_value = fractional_knapsack(n, items, capacity);
    maxi=max_value;
    printf("The maximum value that can be obtained is: %.2f\n", max_value);
    printf("2. Sort by weight in descending order\n");
    qsort(items, n, sizeof(struct item), cmp_weight_desc);
    max_value = fractional_knapsack(n, items, capacity);
    if(max_value>maxi){
        maxi=max_value;
    }
    printf("The maximum value that can be obtained is: %.2f\n", max_value);
    printf("3. Sort by value in ascending order\n");
    qsort(items, n, sizeof(struct item), cmp_value_asc);
    max_value = fractional_knapsack(n, items, capacity);
    if(max_value>maxi){
        maxi=max_value;
    }
    printf("The maximum value that can be obtained is: %.2f\n", max_value);
    printf("4. Sort by value in descending order\n");
    qsort(items, n, sizeof(struct item), cmp_value_desc);
    max_value = fractional_knapsack(n, items, capacity);
    if(max_value>maxi){
        maxi=max_value; 
    }
    printf("The maximum value that can be obtained is: %.2f\n", max_value);
    printf("5. Sort randomly\n");
    max_value = fractional_knapsack(n, items, capacity);
    if(max_value>maxi){
        maxi=max_value;
    }
    printf("The maximum value that can be obtained is: %.2f\n", max_value);
    printf("The optimal solution is  %.2f\n",maxi);
srand(time(NULL));
return 0;
}


Multi-backward:
#include <stdio.h>
#include <limits.h>
#define INF INT_MAX
int main()
{
int graph[12][12] =
 {
 {INF,9,7,3,2,INF,INF,INF,INF,INF,INF,INF},
 {INF,INF,INF,INF,INF,4,2,1,INF,INF,INF,INF},
 {INF,INF,INF,INF,INF,2,7,INF,INF,INF,INF,INF},
 {INF,INF,INF,INF,INF,INF,INF,11,INF,INF,INF,INF},
 {INF,INF,INF,INF,INF,INF,11,8,INF,INF,INF,INF},
 {INF,INF,INF,INF,INF,INF,INF,INF,6,5,INF,INF},
 {INF,INF,INF,INF,INF,INF,INF,INF,4,3,INF,INF},
 {INF,INF,INF,INF,INF,INF,INF,INF,INF,5,6,INF},
 {INF,INF,INF,INF,INF,INF,INF,INF,INF,INF,INF,4},
 {INF,INF,INF,INF,INF,INF,INF,INF,INF,INF,INF,2},
 {INF,INF,INF,INF,INF,INF,INF,INF,INF,INF,INF,5},
 {INF,INF,INF,INF,INF,INF,INF,INF,INF,INF,INF,INF}
 };
 int n=12,stages=5,cost[n],path[n],i,j,k,min,total_cost;
 for (i = 0; i < n; i++)
 {
 cost[i]=INF;
 path[i]=-1;
 }
 cost[n-1]=0;
 for(j=stages-2;j>=0;j--)
  {
 for(i=n-2;i>=j;i--)
 {
 min=INF;
 for(k=i+1;k<n;k++)
 {
 if (graph[i][k]!=INF && graph[i][k]+cost[k]<min)
 {
 min=graph[i][k]+cost[k];
 path[i]=k;
 }
 }
 cost[i]=min;
 }
 }
 printf("The shortest path using backward approach is: \n");
 printf("1-> ");
 i=0;
 total_cost=0;
 while(i!=n-1)
 {
 printf("%d-> ", path[i]+1);
 total_cost=total_cost+graph[i][path[i]];
 i=path[i];
 }
 printf("\n-----------------------\nThe total path cost is: %d\n-----------------------",total_cost);
 return 0;
 }


Multi-Forward:
#include <stdio.h>
#include <limits.h>
#define MAX_NODES 100
#define INF INT_MAX
int n; // number of nodes
int cost[MAX_NODES]; // minimum cost to reach each node
int path[MAX_NODES]; // previous node in shortest path
int graph[MAX_NODES][MAX_NODES]; // adjacency matrix of the graph
int main() {
    printf("Enter the number of nodes: ");
    scanf("%d", &n);
        // read the adjacency matrix of the graph
    printf("Enter the adjacency matrix of the graph:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &graph[i][j]);
            if (graph[i][j] == 0 && i != j) {
                graph[i][j] = INF;
            }

        }
    }
    
    // initialize the cost and path arrays
    for (int i = 0; i < n; i++) {
        cost[i] = INF;
        path[i] = -1;
    }
    cost[n-1] = 0;
    
    // calculate the minimum cost to reach each node
    for (int i = n-2; i >= 0; i--) {
        for (int j = i+1; j < n; j++) {
            if (graph[i][j] != INF) {
                int dist = graph[i][j] + cost[j];
                if (dist < cost[i]) {
                    cost[i] = dist;
                    path[i] = j;
                }
            }
        }
    }
    
    // print the shortest path
    printf("Shortest path cost: %d\n", cost[0]);
    printf("Path: ");
    int j = path[0];
    printf("0 -> ");
    while (j != -1) {
        printf("%d -> ", j);
        j = path[j];
    }
    printf("%d\n", n-1);
    
    return 0;
}



All-Pair:
#include <stdio.h>
#include <limits.h>

#define MAXN 100 // maximum number of vertices in the graph
#define INF INT_MAX // infinity value for initializing distance matrix

int n; // number of vertices in the graph
int m; // number of edges in the graph
int graph[MAXN][MAXN]; // adjacency matrix representation of the graph
int dist[MAXN][MAXN]; // matrix to store the shortest distance between any two vertices

int min(int a, int b) {
    return (a < b) ? a : b;
}

void floyd_warshall() {
    // initialize distance matrix with the adjacency matrix of the graph
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            dist[i][j] = graph[i][j];
        }
    }

    // apply the Floyd-Warshall algorithm
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
}

int main() {
    // read the graph from input
    printf("Enter the number of vertices in the graph: ");
    scanf("%d", &n);
    printf("Enter the number of edges in the graph: ");
    scanf("%d", &m);
    printf("Enter the edges of the graph (vertex1 vertex2 weight):\n");
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        graph[u][v] = w;
    }

    // initialize distance matrix
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i == j) {
                dist[i][j] = 0;
            } else if (graph[i][j] > 0) {
                dist[i][j] = graph[i][j];
            } else {
                dist[i][j] = INF;
            }
        }
    }

    // apply Floyd-Warshall algorithm
    floyd_warshall();

    // print the shortest distance between any two vertices
    printf("The shortest distance between any two vertices:\n");
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            printf("%d ", dist[i][j]);
        }
        printf("\n");
    }

    return 0;
}


All Pair Shortest path (Build):
#include<stdio.h>
#include<stdlib.h>
#define V 4
#define INF 99999
void printsolution(int dist[][V]);
void floyd_warshall(int graph[][V])
{
	int dist[V][V],i,j,k;
	for(i=0;i<V;i++)
	{
		for(j=0;j<V;j++)
		{
			dist[i][j]=graph[i][j];
		}
	}
	for(k=0;k<V;k++)
	{
		for(i=0;i<V;i++)
		{
			for(j=0;j<V;j++)
			{
				if(dist[i][j]>dist[i][k]+dist[k][j] && dist[i][k]!=INF && dist[k][j]!=INF)
				{
					dist[i][j]=dist[i][k]+dist[k][j];
				}
			}
		}
	}
	printsolution(dist);
}
void printsolution(int dist[][V])
{
	int i,j;
	for(i=0;i<V;i++)
	{
		for(j=0;j<V;j++)
		{
			if(dist[i][j]==INF)
			{
				printf("INF ");
			}
			else
			{
				printf("%d ",dist[i][j]);
			}
		}
		printf("\n");
	}
}

int main()
{
	int graph[V][V]={{0,5,INF,10},{INF,0,3,INF},{INF,INF,0,1},{INF,INF,INF,0}};
	floyd_warshall(graph);
	return 0;
}


Knapsack(Build):
#include<stdio.h>
#include<stdlib.h>

float knapsack(int n,float w[],float p[],float c)
{
	float x[20],tp=0,u;
	int i,j;
	u=c;
	
	for(i=0;i<n;i++)
	{
		x[i]=0.0;
	}
	
	for(i=0;i<n;i++)
	{
		if(w[i]>u)
		{
			break;
		}
		else
		{
			x[i]=1.0;
			tp=tp+p[i];
			u=u-w[i];
		}
	}
	
	if(i<n)
	{
		x[i]=u/w[i];
	}
	tp=tp+(x[i]*p[i]);
	
	printf("The result vector is : ");
	for(i=0;i<n;i++)
	{
		printf("%f\t",x[i]);
	}
	printf("\n");
	printf("Maximum profit is : %f  ",tp);
}
int main()
{
	float w[20],p[20],c;
	int num,i,j;
	float ratio[20],temp;
	
	printf("Enter the no: of objects:");
	scanf("%d",&num);
	
	printf("Enter the weights and profits in order:- ");
	for(i=0;i<num;i++)
	{
		scanf("%f %f",&w[i],&p[i]);
	}
	
	printf("Enter the capacity of knapsack : ");
	scanf("%f",&c);
	
	for(i=0;i<num;i++)
	{
		ratio[i]=p[i]/w[i];
	}
	
	for(i=0;i<num;i++)
	{
		for(j=i+1;j<num;j++)
		{
			if(ratio[i]<ratio[j])
			{
				temp=ratio[j];
				ratio[j]=ratio[i];
				ratio[i]=temp;
				
				temp=w[j];
				w[j]=w[i];
				w[i]=temp;
				
				temp=p[j];
				p[j]=p[i];
				p[i]=temp;
			}
		}
	}
	knapsack(num,w,p,c);
}
